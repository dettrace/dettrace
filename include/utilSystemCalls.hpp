#ifndef UTIL_SYSTEM_CALLS
#define UTIL_SYSTEM_CALLS

#include "ptracer.hpp"
#include "globalState.hpp"
#include "state.hpp"
#include "logger.hpp"
#include "scheduler.hpp"
#include <optional>
/**
 * Compare returned value of system call (rax) vs the blocking value (errnoValue negated),
 * e.g. EAGAIN. If equal, system call would have blocked, log it, preempt current running
 * process, and schedule someone else.
 * Does not replay system call!
 */
bool preemptIfBlocked(globalState& gs, state& s, ptracer& t, scheduler& sched,
                      int64_t errornoValue);

/**
 * Utility functions related to dettraceSystemCall.cpp, that is, helper functions for the
 * pre and post hooks.
 */
void zeroOutStatfs(struct statfs& stats);

/**
 * All stat functions can be handled the same, newfstatat is special. Pass the name of
 * the function to syscallName if it's "newfstatat" it's treated specially.
 */
void handleStatFamily(globalState& gs, state& s, ptracer& t, string syscallName);

/**
 * Helper function to print path for system call.
 * Given the address of the string (this can be fetched by t.argN() ).
 * It will print this string as a green text to the logger.
 *
 * @arg postFix: This is a default argument. Usually " path:" unless something
 * else is given.
 */
void printInfoString(uint64_t addr, logger &log, pid_t traceePid, ptracer& t,
                     string postFix = " path: ");

void injectPause(globalState& gs, state& s, ptracer& t);

pair<int,int> getPipeFds(globalState& gs, state& s, ptracer& t);

/* Turn system call into a noop by changing it into a time. This should be called from
 *the pre hook only! We use time (a vdso system call), since we don't expect it to be
 * called often, unlike getpid, which is expensive to use as a noop since it is called a
 * lot.
 */
void replaceSystemCallWithNoop(globalState& gs, state& s, ptracer& t);

void appendEnvpLdPreload(globalState& gs, state& s, ptracer& t);

/**
 * Go through "/proc/$tracee_pid/fd/$fd" to get the file descriptor represented by fd.
 * Basically, do a stat by looking at /proc/ section of the tracee.
 * Calls stat("/proc/$tracee_pid/fd/$fd") which dereferences symbolic link. This is fine,
 * unless your path _is_ a symbolic link. You will end up derreferencing too many symbolic
 * links!
 * Assumes that `fd` is currently open for traceePid.
 */
ino_t readInodeFor(logger& log, pid_t traceePid, int fd);

/**
 * Takes care of resolution for a path relative to the tracee process.
 * Properly handles relative paths (cwd), and chroots, to reach correct file from the
 * tracee's point of view.
 * Uses traceeDirFd to mimic semantics of *at symstem calls, e.g. mkdirat. See man 2 mkdirat
 * for specific semantics. Use value -1 as poor man's optional type NONE.
 * Assumes that `traceeDirFd` is currently open for traceePid.
 */
ino_t inode_from_tracee(string traceePath, pid_t traceePid, logger& log,
                        int traceeDirFd);

/**
 *
 * Replays system call if the value of errnoValue is equal to the errno value that the libc
 * call would have returned. Also logs event in logger. For example for read:
 *   replaySyscallIfBlocked(s, t, sched, EAGAIN);
 *
 * @return: true if call was replayed, else false.
 */
bool replaySyscallIfBlocked(globalState& gs, state& s, ptracer& t,
                            scheduler& sched, int64_t errnoValue);

/**
 * Replay system call by rewinding the PC register. Does NOT restore old
 * arguments of system call. Make sure this is what you want.
 */
void replaySystemCall(globalState& gs, ptracer& t, uint64_t systemCall);

/**
   This function provides unified handling for timer-based signals stemming from
   alarm(), setitimer() and timer_create().

   The first step is to track a tracee's signal handlers, which can be set via
   rt_sigaction() -- on cat16 at least, the signal() and sigaction() ultimately
   resolve to the rt_sigaction() syscall. Any given signal may be ignored, set
   to its default behavior (usually termination, but it varies by signal), or
   have a custom handler. These handlers for all signals are tracked in
   the state::currentSignalHandlers map.

   Then, when a tracee requests a signal be delivered some time in the future,
   we convert this request into immediate deterministic signal delivery. Let's
   refer to alarm(), setitimer() and timer_settime() as signal-generated
   functions (SGFs).

   If the signal generated by the SGF is being ignored, then we convert the SFG
   into a NOP: instead of actually having a signal sent and risking some
   nondeterministic EINTR on some other system call, we don't send the signal in
   the first place and the tracee shouldn't be able to tell.

   If the signal generated by the SGF is set to cause termination (usually the
   default behavior), we convert the SGF into an exit() syscall.

   If the signal generated by the SGF invokes a custom handler, then we have to
   actually send a real signal. We convert the SGF into a pause() syscall and
   send a real signal from the tracer to the tracee via tgkill(). When the
   tracee receives the signal, its handler will run and pause() will then
   return.
*/
bool sendTraceeSignalNow(int signum, globalState& gs, state& s, ptracer& t,
                         scheduler& sched);

/**
 * Given a path used by the tracee, either relative or absolute, resolve the exact file the
 * tracee refered to. Uses combination of /proc/traceePid/cwd, /proc/traceePid/root, to
 * resolve path. Takes optional dirfd argument, for tracee calls using *at.
 */
string resolve_tracee_path(string traceePath, pid_t traceePid, logger& log,
                           int traceeDirFd);

/**
 * Check if a file relative to a tracee exists. Calls resolve_tracee_path,
 * uses stat on file to emulate behavior of open() and openat().
 */
bool tracee_file_exists(string traceePath, pid_t traceePid, logger& log,
                        int traceeDirFd);
/**
 * Handler for open and openat. Checks if the file exists and sets s.fileExisted,
 * if O_CREAT was set. This way we know whether a new file was created if the system
 * call suceeds.
 */
void handlePreOpens(globalState& gs, state& s, ptracer& t, int dirfd,
                    traceePtr<char> charpath, int flags);
/**
 * Handler for open and openat. Checks if the file previously existed, if it didn't
 * and O_CREAT was set, we know a new file was created. Handles O_TMPFILE by knowing
 * this file is brand new and using the fd returned from open/openat to get the
 * anonymous inode.
 */
void handlePostOpens(globalState& gs, state& s, ptracer& t, int flags);
#endif

